<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Title</title>
  <meta name="viewport" content="initial-scale=1,user-scalable=no"/>
  <link rel="stylesheet" href="../dist/chunked-show.min.css">

</head>
<body>

<div class="chunked-show">

  <div class="cs-top-half">
    <div class="cs-cont">

      <div class="test-cont">
        display: table-cell;
        记得有一种display 高度自动撑满容器的

        ---

        ChangeAnime动画 结合 缓动

        ---
        当动画结束后，删掉css，会自动会干掉此事件
        animationend
        ---
        18702077283

        补成2位
        (currentDate.getMonth() + 1+'').replace(/^\d$/,'0$&')


        ---
        transform: skewX(30deg);
        ---

        clientWidth 无法取到 inline 元素的尺寸，可使用 inline-block 代替

        offsetWidth 都可以

        此发现兼容性如何

        ---

        不return或者return undefined相当于 Promise.resolve()

        setTimeout(fn, 0)在下一轮“事件循环”开始时执行，Promise.resolve()在本轮“事件循环”结束时执行，console.log(’one‘)则是立即执行，因此最先输出。

        display: table-cell;
        记得有一种display 高度自动撑满容器的

        ---

        ChangeAnime动画 结合 缓动

        ---
        当动画结束后，删掉css，会自动会干掉此事件
        animationend
        ---
        18702077283

        补成2位
        (currentDate.getMonth() + 1+'').replace(/^\d$/,'0$&')


        ---
        transform: skewX(30deg);
        ---

        clientWidth 无法取到 inline 元素的尺寸，可使用 inline-block 代替

        offsetWidth 都可以

        此发现兼容性如何

        ---

        不return或者return undefined相当于 Promise.resolve()

        setTimeout(fn, 0)在下一轮“事件循环”开始时执行，Promise.resolve()在本轮“事件循环”结束时执行，console.log(’one‘)则是立即执行，因此最先输出。
        display: table-cell;
        记得有一种display 高度自动撑满容器的

        ---

        ChangeAnime动画 结合 缓动

        ---
        当动画结束后，删掉css，会自动会干掉此事件
        animationend
        ---
        18702077283

        补成2位
        (currentDate.getMonth() + 1+'').replace(/^\d$/,'0$&')


        ---
        transform: skewX(30deg);
        ---

        clientWidth 无法取到 inline 元素的尺寸，可使用 inline-block 代替

        offsetWidth 都可以

        此发现兼容性如何

        ---

        不return或者return undefined相当于 Promise.resolve()

        setTimeout(fn, 0)在下一轮“事件循环”开始时执行，Promise.resolve()在本轮“事件循环”结束时执行，console.log(’one‘)则是立即执行，因此最先输出。
      </div>

    </div>

  </div>
  <div class="cs-drag-bar"><b></b></div>
  <div class="cs-bottom-half">

  </div>
</div>

<script src="../dist/chunked-show.min.js"></script>
<script>
  let eBox = document.querySelector('.chunked-show');

  let chunkedShow = new ChunkedShow({
    eBox
  });
  chunkedShow.chunked();

</script>
</body>
</html>
